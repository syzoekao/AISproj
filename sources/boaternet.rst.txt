.. _Predictive Model: 

============================================
Predictive Model of Boater Movement Networks
============================================

* The observed boater movement network constructed from the Watercraft Inspection Program did not observe all the boater movements among all 9,183 lakes. 
* To accurately predict the risk of AIS invasion of each lake, a complete boater movement network is waranted. 
* We constructed two predictive models to predict the boater movements between lakes using extreme gradient boosting (xgboost).
* M1: We first predicted whether a directional edge existed between a pair of lakes (whether there were boaters traveling from lake A to lake B). 
* M2: We then predicted the edge weight (the number of boaters traveling from lake A to lake B). 
* We conducted the predictive model using xgboost package (version 0.90) in Python 3.7.3. 
* We described the boater movement data used to construct the predictive model in :ref:`Data`. 

----------------------------------
M1: Link prediction between lakes 
----------------------------------

* We reshaped the boater movement data among the 738 inspected lakes to build the predictive model. 
* For each inspected lake *i*, we created a directional dataset with 9,182 rows where the lake *i* was the destination lake and the other 9,182 lakes were origin lakes plus another 9,182 rows where the lake *i* was the origin lake and the other 9,182 lakes were destination lakes. 
* We then constructed a binary outcome variable indicating whether a pair of origin and destination lakes was observed in the boater movement data (= 1) or not (= 0). 
* By removing duplicates and self loops, the data set contained about 13 million rows. 
* We predicted whether a link existed using the lake attributes including: 

.. list-table:: Features included in M1
	:widths: 10 30
	:header-rows: 1

	* - Features
	  - Description
	* - insp_o
	  - whether the origin lake was an inspected lake 
	* - insp_d
	  - whether the destination lake was an inspected lake 
	* - same_insp
	  - whether both origin lake and destination lake had the same inspection status 
	* - infest_o
	  - whether the origin lake was an infested lake
	    (infested by any listed invasive species)
	* - infest_d
	  - whether the destination lake was an infested lake
	    (infested by any listed invasive species)
	* - both_infest
	  - whether both origin and destination lakes were infested with any listed invasive species	    
	* - dist50 
	  - whether the distance between the pair of lakes was ≤ 50 miles
	* - log_distance 
	  - log transformed distance between the pair of lakes
	* - log_dist_x_dist50
	  - log transformed distance between the pair of lakes multipled by dist50
	* - log_acre_o
	  - log transformed lake size of the origin lake
	* - log_acre_d
	  - log transformed lake size of the destination lake
	* - log_acre_diff
	  - log transformed difference in lake size between origin and destination lakes
	* - log_boat_o
	  - log transformed predicted total arrival traffic to the origin lake
	* - log_boat_d
	  - log transformed predicted total arrival traffic to the destination lake
	* - log_boat_diff
	  - log transformed difference in arrival traffic between the origin and the destination lakes
	* - log_ramp_acre_o
	  - log transformed ramps per acre of the origin lake multiplied by 1,000
	* - log_ramp_acre_d
	  - log transformed ramps per acre of the destination lake multiplied by 1,000

* All the log tranformed features were added by 1 before transformation. 
* We assumed that the self-loop always existed. That is, there were always some boaters remaining on the same lake. 


Selecting an xgboost model
--------------------------

* Because the binary nature of the outcome variable, we used logistic function as the objective (loss) function, and chose a tree-based booster. 
* We conducted grid search using 3-fold cross validation among 80% of the reconstructued movement data to roughly tune the hyperparameters associated with xgboost, including n_estinators, gamma, max_depth, min_child_weight, subsample, colsample_bytree. 
* We used the area under the curve (auc) to select the final model. 

.. code-block:: python

	xgb1 = XGBClassifier(
		learning_rate = 0.1,
		n_estimators = 267,
		max_depth = 8,
		min_child_weight = 28,
		gamma = 0.4,
		eta = 0.3, 
		subsample = 0.4,
		colsample_bytree = 0.7,
		objective = 'binary:logistic',
		booster = 'gbtree', 
		nthread = os.cpu_count() - 1,
		eval_metric = 'auc', 
		scale_pos_weight = 168)

* We used the model to predict the probability of link formation among the rest of 20% of the reconstructued boater movements (test data). 
* We did not use the traditional 0.5 as the cut-off probability. Instead, we picked a cut-off probability by allowing the sensitivity (proportion of accurate predicted edges among the observed edges) to be at least 0.95 and the accuracy (proportion of correctly classified samples) to be at least 0.92. 
	
	* Sensitivity: proportion of true positive edges predicted given the observed edges. 
	* Accuracy: :math:`\frac{true\ postive\ edges\ predicted + true\ negative\ edges\ predicted} {total\ sample}`
	* We cared less about false positive rate (1 - specificity) because a link might still exit even though it was not observed in the movement data. 

* The final cut-off probability is 0.36. The model performance among the test set is displayed below: 

.. list-table:: Model performance among the test set
	:widths: 15 15 15
	:header-rows: 2

	* - 
	  - observed data
	  - 
	* - prediction
	  - 0
	  - 1
	* - 0
	  - 2,396,629
	  -       755
	* - 1
	  -   189,982
	  -    14,379
	* - Sensitivity
	  - 95.0%
	  -
	* - Specificity
	  - 92.7%
	  -
	* - Accuracy
	  - 92.7%
	  -
	* - AUC
	  - 93.8%
	  -

---------------------------------------
M2: Predicting edge weight of each link
---------------------------------------

* We predicted the number of boaters of each pair of lakes using the observed boater movement data. The number of boaters among the observed edges ranged from 1 to 76,966. 
* Because the wide range of the number of observed boaters, we log transformed the outcome variable. 
* The features used to build the predictive model included: 

.. list-table:: Features included in M2
	:widths: 10 30
	:header-rows: 1

	* - Features
	  - Description
	* - self_loop
	  - whether the origain and the destination lakes were the same lake 
	* - insp_o
	  - whether the origin lake was an inspected lake 
	* - insp_d
	  - whether the destination lake was an inspected lake 
	* - same_insp
	  - whether both origin lake and destination lake had the same inspection status 
	* - infest_o
	  - whether the origin lake was an infested lake
	    (infested by any listed invasive species)
	* - infest_d
	  - whether the destination lake was an infested lake
	    (infested by any listed invasive species)
	* - same_infest
	  - whether the origin and the destination lakes had the same infestation status (0: neither were infested with any listed infested species; 1: both were infested with at least one listed infested species)
	* - dist50 
	  - whether the distance between the pair of lakes was ≤ 50 miles
	* - log_distance 
	  - log transformed distance between the pair of lakes
	* - log_distance2
	  - square term of log transformed distance between the pair of lakes
	* - log_distance3
	  - cube term of log transformed distance between the pair of lakes
	* - log_dist_x_dist50
	  - log transformed distance between the pair of lakes multipled by dist50
	* - log_acre_o
	  - log transformed lake size of the origin lake
	* - log_acre_o2
	  - square term of log transformed lake size of the origin lake
	* - log_acre_d
	  - log transformed lake size of the destination lake
	* - log_acre_d2
	  - square term of log transformed lake size of the destination lake
	* - log_acre_d3
	  - cube term of log transformed lake size of the destination lake
	* - log_acre_diff
	  - log transformed difference in lake size between origin and destination lakes
	* - log_acre_diff2
	  - square term of log transformed difference in lake size between origin and destination lakes
	* - log_acre_diff3
	  - cube term of log transformed difference in lake size between origin and destination lakes
	* - log_boat_o
	  - log transformed predicted total arrival traffic to the origin lake
	* - log_boat_o2
	  - square term of log transformed predicted total arrival traffic to the origin lake
	* - log_boat_o3
	  - cube term of log transformed predicted total arrival traffic to the origin lake	
	* - log_boat_d
	  - log transformed predicted total arrival traffic to the destination lake
	* - log_boat_d2
	  - square term of log transformed predicted total arrival traffic to the destination lake	
	* - log_boat_d3
	  - cube term of log transformed predicted total arrival traffic to the destination lake	
	* - log_boat_diff
	  - log transformed difference in arrival traffic between the origin and the destination lakes
	* - log_boat_diff2
	  - square term of log transformed difference in arrival traffic between the origin and the destination lakes
	* - log_boat_diff3
	  - cube term of log transformed difference in arrival traffic between the origin and the destination lakes
	* - log_ramp_acre_o
	  - log transformed ramps per acre of the origin lake
	* - log_ramp_acre_d
	  - log transformed ramps per acre of the destination lake

* Similarly, all the log tranformed features were added by 1 before transformation. 


Selecting an xgboost model
--------------------------

* Because the outcome variable is continuous, we used regression with squared loss ``reg:squarederror`` as the objective (loss) function, and chose a tree-based booster. 
* We conducted grid search using 3-fold cross validation among 80% of the observed movement data to roughly tune the hyperparameters associated with xgboost, including n_estinators, gamma, max_depth, min_child_weight, subsample, colsample_bytree. 
* We used the root mean squared error (rmse) to select the final model. 
* The final model selected is

.. code-block:: python

	xgb1 = XGBRegressor(
		learning_rate = 0.1,
		n_estimators = 640,
		max_depth = 8,
		min_child_weight = 19,
		gamma = 0.3,
		eta = 0.3, 
		subsample = 0.9,
		colsample_bytree = 1,
		objective = 'reg:squarederror',
		booster = 'gbtree', 
		nthread = os.cpu_count() - 1,
		eval_metric = 'rmse')


* We used the model to predict the log transformed number of boaters among the 20% test set. We then transformed the predicted number of boaters back to the original scale. 
* The distribution and the correlation of the predicted and the observed boaters are presented below 

.. raw:: html

	<img src="fig/boaters_prediction(distribution).png" style="width: 80%">

.. raw:: html

	<img src="fig/boaters_prediction(pred vs actual).png" style="width: 80%">

* Compared between all the observed and predicted boater movements, the correlation could be as high as 0.921. 

.. raw:: html

	<img src="fig/boaters_prediction(pred vs actual) post.png" style="width: 80%">


-------------------------------------------
Simulating boater movement networks in MN 
-------------------------------------------

* We used the two predictive models to simulate 20 boater movement networks among the 9,183 lakes in MN. 
* Using M1, we predicted the probability of edge formation between any pair of lakes. 
	
	* If the predicted probability was ≥ 0.36, we assumed the link existed; if the predicted probability was < 0.36, we randomly sample whether or not a link exists between the pair using binomial distribution. 

* Using M2, we predicted the number of boater movements between a pair of lakes that a predicted edge existed. 

	* We assumed the predicted number of boaters between the pair of lakes was the mean and randomly sampled the number of boaters using a Poisson distribution. 

* Across all 20 networks, 
	
	* The average true positive rate is 98.5% with a standard deviation of 0.02%. The average true negative rate is 90% with a standard deviation of 0.004%. 





